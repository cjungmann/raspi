#!/usr/bin/env bash

declare coloron="[31;1m"
declare coloroff="[m"

declare -f NECHO
is_root() { [ "$USER" = "root" ]; }

echo_notify()
{
    local msg="${1}"

    local -a rearr=(
        '(^|[^_])'     # match beginning of string or a of non-asterisk character
        '_'              # match the *
        '([^_]+)'      # match characters between the pair of asterisks
        '_'              # match the *
        '([^_]|$)'     # match a non-asterisk character or the end of the string
    )

    local IFS=""
    echo "$msg" | sed -E "s/${rearr[*]}/\1[31;1m\2[m\3/g" >&2
}

nc_notify()
{
    local msg="${1}"

    echo_notify "sending $msg to $nc_address:"

    echo "$msg" | nc "$nc_address" "$nc_port"
}

already_installed()
{
    local pname="$1"
    local gresult
    gresult=$( dpkg -s "${pname}" 2>/dev/null | grep ^Status )
    # falling out of function will allow calling function to
    # query the result of the `which` command.
}

already_snapped()
{
    local name="$1"
    local gresult=$( which "$name" > /dev/null  )
    # falling out of function will allow calling function to
    # query the result of the `which` command.
}    

hl_snap()
{
    local name="$1"
    if already_snapped "$name"; then
        $NECHO "_${name}_ is already installed with snap"
    else
        $NECHO "Installing _${name}_."
        snap install "${name}"
    fi
}

hl_install()
{
    local name="$1"

    if already_installed "$name"; then
        $NECHO "_${name}_ is already installed"
    else
        $NECHO "Installing _${name}_"
        sudo apt-get -y install "${name}"
    fi
}

show_usage()
{
    $NECHO "This utility must be run as root to install applications."
}

do_initial_os_update()
{
    apt-get update
}

run_onload_scripts()
{
    local -a scripts=( $( ls -1 ) )
    local script
    for script in "${scripts[@]}"; do
        if [ -x "$script" ] && ! [ "${script:0:1}" = '_' ]; then
            sudo ./$script
        fi
    done
}

#########################
# Execution Begins Here #
#########################

NECHO=echo_notify

if [ -f "nc_address" ]; then
    source nc_address
    NECHO=nc_notify
fi

if is_root; then
    echo "Announcing the commencement of [32;1mload_apps[m. (stdin)"
    echo "Announcing the commencement of [32;1mload_apps[m. (stderr)" >&2

    $NECHO "_Updating packages list to get latest version of software._"
    apt-get update
    apt-get -y upgrade

    hl_install emacs-nox
    hl_install locate
    hl_install git

    # mdless is a tool for reading markdown files.  We need snapd to install it.
    # hl_install snapd
    # hl_snap mdless

    # Enable systemd-resolved.service to enable resolvectl command
    systemctl enable systemd-resolved.service

    # Configure for EMACS use:
    # Only change editor value if it's not already set.
    if [ -z "$EDITOR" ]; then
        echo "Setting empty EDITOR value to 'emacs'"
        echo "export EDITOR=emacs"
    fi

    if grep -q -P 'INFOPATH.*emacs' ~/.bashrc; then
        echo "[31;1mNot changing INFOPATH to find emacs info page.[m"
    else
        echo "Telling pinfo where to find emacs info page"
        echo >> ~/.bashrc
        echo "# Help pinfo find emacs info page" >> ~/.bashrc
        echo "export INFOPATH=/usr/share/info/emacs" >> ~/.bashrc     # Make an alias so invoking 'info' opens 'pinfo'
    fi

    # Do custom scripts last, in case a script results in a reboot:
    if [ -d /home/pi/onload.d ]; then
        pushd /home/pi/onload.d
        run_onload_scripts
        popd
    fi

else
    show_usage
fi

